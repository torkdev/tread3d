// MAC_CSTRING.CPP// Copyright (c) 2000 Joe Riedel, Nick Randal.// Author: Joe Riedel.#include "stdafx.h"#include <string.h>#include <stdlib.h>#include <stdio.h>#include <stdarg.h>#include <ctype.h>#include "futils.h"// Replacement class to MFC standard string.CString::CString(){	m_pString = NULL;	m_nLength = 0;}CString::CString(const CString& ToCopy){	m_pString = NULL;	m_nLength = 0;	*this = ToCopy;}CString::CString(const char* pString){	m_pString = NULL;	m_nLength = 0;		*this = pString;}CString::~CString(){	FreeData();}void CString::FreeData(){	if(m_pString != NULL)		delete[] m_pString;		m_pString = NULL;	m_nLength = 0;}void CString::Format(const char* format, ...){	va_list argptr;	char	text[512];		va_start(argptr, format);	vsprintf(text, format, argptr);	va_end(argptr);		*this = text;}bool CString::IsEmpty(){	return m_nLength == 0;}int CString::Find(const char* szString){	char* str;		if(m_nLength == 0)		return -1;		str = strstr(m_pString, szString);	if(str == m_pString || str == 0)		return -1;	return (int)(str-m_pString);}int CString::Delete(int nIndex, int nCount){	if(m_nLength == 0)		return 0;	if(nIndex > m_nLength-1 || nIndex < 0)		return m_nLength;	if(nCount == 0)		return m_nLength;			if((nCount+nIndex) > m_nLength)		nCount -= (nCount+nIndex)-m_nLength;			char* str1 = m_pString;	char* str2 = m_pString;		str1[nIndex+nCount-1] = 0; // Terminate it at the last char to delete.	str2 = &str2[nIndex+nCount];		m_pString = 0;	m_nLength = 0;	*this = str1;	*this += str2;	return m_nLength;}CString& CString::operator += (const char c){	char* pOld;	int nNewLen;		// Allocate one more char.	nNewLen = m_nLength + 1;		pOld = m_pString;	m_pString = new char[nNewLen+1];		if(m_nLength > 0)		strcpy(m_pString, pOld);				m_pString[nNewLen-1] = c;	m_pString[nNewLen] = 0;		delete[] pOld;	m_nLength = nNewLen;	return *this;		}CString::operator const char*() const{	return m_pString;}CString& CString::operator += (const CString& sOther){	*this = *this + sOther;	return *this;}CString& CString::operator += (const char* szOther){	*this = *this + szOther;	return *this;}	const CString& CString::operator = (const CString& sSrc){	if(sSrc.m_pString == m_pString)		return sSrc;		FreeData();	if(sSrc.m_nLength == 0)	{		this->m_pString = NULL;		this->m_nLength = 0;	}	else	{		this->m_nLength = sSrc.m_nLength;		this->m_pString = new char[this->m_nLength+1];		if(this->m_pString == NULL)		{			this->m_nLength = 0;			return sSrc;		}				strcpy(this->m_pString, sSrc.m_pString);	}		return sSrc;}const char* CString::operator = (const char* szSrc){	if(m_pString == szSrc)		return szSrc;			FreeData();		int nLen;		if(szSrc == NULL)		nLen = 0;	else		nLen = strlen(szSrc);	if(nLen == 0)	{		m_pString = NULL;		m_nLength = 0;		return szSrc;	}		m_pString = new char[nLen+1];	strcpy(m_pString, szSrc);	m_nLength = nLen;	return szSrc;}bool operator != (const CString& sString, const CString& sOther){	return !(sString==sOther);}bool operator != (const CString& sString, const char* szOther){	return !(sString == szOther);}bool operator == (const CString& sString, const char* szOther){	int nLen;		if(szOther == NULL)		nLen = 0;	else		nLen = strlen(szOther);			if(sString.m_nLength != nLen)		return false;	if(sString.m_nLength == 0 && nLen == 0)		return true;	return strcmp(sString.m_pString, szOther) == 0;}bool operator == (const CString& sString, const CString& sOther){	if(sString.m_nLength != sOther.m_nLength)		return false;	if(sString.m_nLength == 0 && sOther.m_nLength == 0)		return true;	return strcmp(sString.m_pString, sOther.m_pString) == 0;}CString operator + (const CString& sString, const CString& sOther){	CString sAdd;		sAdd.m_nLength = sString.m_nLength + sOther.m_nLength;	if(sAdd.m_nLength == 0)		return sAdd;	if(sString.m_nLength == 0)	{		sAdd = sOther;		return sAdd;	}	else if(sOther.m_nLength == 0)	{		sAdd = sString;		return sAdd;	}		sAdd.m_pString = new char[sAdd.m_nLength+1];	strcpy(sAdd.m_pString, sString.m_pString);	strcat(sAdd.m_pString, sOther.m_pString);	return sAdd;}int CString::GetLength(){	return m_nLength;}void CString::Replace(char a, char b){	int i;	for(i = 0; i < m_nLength; i++)	{		if(m_pString[i] == a)			m_pString[i] = b;	}}CString operator + (const char* szString, const CString& sString){	CString sAdd;	int nLen;		if(szString == NULL)		nLen = 0;	else		nLen = strlen(szString);			sAdd.m_nLength = sString.m_nLength + nLen;	if(sAdd.m_nLength == 0)		return sAdd;	if(sString.m_nLength == 0)	{		sAdd.m_nLength = nLen;		sAdd.m_pString = new char[nLen+1];		strcpy(sAdd.m_pString, szString);				return sAdd;	}	else if(nLen == 0)	{		sAdd = sString;		return sAdd;	}		sAdd.m_pString = new char[sAdd.m_nLength+1];	strcpy(sAdd.m_pString, szString);	strcat(sAdd.m_pString, sString.m_pString);	return sAdd;}CString operator + (const CString& sString, const char* szOther){	CString sAdd;	int nLen;		if(szOther == NULL)		nLen = 0;	else		nLen = strlen(szOther);			sAdd.m_nLength = sString.m_nLength + nLen;	if(sAdd.m_nLength == 0)		return sAdd;	if(sString.m_nLength == 0)	{		sAdd.m_nLength = nLen;		sAdd.m_pString = new char[nLen+1];		strcpy(sAdd.m_pString, szOther);				return sAdd;	}	else if(nLen == 0)	{		sAdd = sString;		return sAdd;	}		sAdd.m_pString = new char[sAdd.m_nLength+1];	strcpy(sAdd.m_pString, sString.m_pString);	strcat(sAdd.m_pString, szOther);	return sAdd;}char CString::operator[](int nIndex) const{	if(nIndex >= m_nLength)		return 0;			return m_pString[nIndex];}	void CString::MakeLower(){	int i;		for(i = 0; i < m_nLength; i++)		m_pString[i] = (char)tolower(m_pString[i]);}void CString::MakeUpper(){	int i;		for(i = 0; i < m_nLength; i++)		m_pString[i] = (char)toupper(m_pString[i]);}void CString::ConvertUnixPath(){	if(m_nLength > 0)		::ConvertUnixPath(m_pString);}